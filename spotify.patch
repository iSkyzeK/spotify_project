diff --git a/.env.template b/.env.template
index dba4268..360bc19 100644
--- a/.env.template
+++ b/.env.template
@@ -1,2 +1,3 @@
 VITE_SPOTIFY_CLIENT_ID=
 VITE_SPOTIFY_CLIENT_SECRET=
+VITE_SPOTIFY_REDIRECT_URI=http://localhost:5173/spotify/callback/
diff --git a/README.md b/README.md
index c0aa873..f3a27b3 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,20 @@
 Sakai is an application template for Vue based on the [create-vue](https://github.com/vuejs/create-vue), the recommended way to start a Vite-powered Vue projects.
 
 Visit the [documentation](https://sakai.primevue.org/documentation) to get started.
+
+## Configuration
+
+Copiez `.env.template` vers `.env` et remplissez les valeurs suivantes :
+
+```
+VITE_SPOTIFY_CLIENT_ID=<votre id>
+VITE_SPOTIFY_CLIENT_SECRET=<votre secret>
+VITE_SPOTIFY_REDIRECT_URI=http://localhost:5173/spotify/callback/
+```
+
+Lancez le projet avec :
+
+```bash
+npm install
+npm run dev
+```
diff --git a/index.html b/index.html
index 2975cdc..c7b65bf 100644
--- a/index.html
+++ b/index.html
@@ -1,17 +1,18 @@
 <!DOCTYPE html>
 <html lang="en">
 
 <head>
       <meta charset="UTF-8">
       <link rel="icon" href="/favicon.ico">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
+      <link rel="manifest" href="/manifest.webmanifest">
       <title>Sakai Vue</title>
       <link href="https://fonts.cdnfonts.com/css/lato" rel="stylesheet">
 </head>
 
 <body>
       <div id="app"></div>
       <script type="module" src="/src/main.js"></script>
 </body>
 
 </html>
\ No newline at end of file
diff --git a/public/manifest.webmanifest b/public/manifest.webmanifest
new file mode 100644
index 0000000..b07f1be
--- /dev/null
+++ b/public/manifest.webmanifest
@@ -0,0 +1,9 @@
+{
+  "name": "Spotify Vue",
+  "short_name": "Spotify",
+  "start_url": "/",
+  "display": "standalone",
+  "background_color": "#ffffff",
+  "description": "Spotify Vue offline",
+  "icons": []
+}
diff --git a/public/service-worker.js b/public/service-worker.js
new file mode 100644
index 0000000..14d5152
--- /dev/null
+++ b/public/service-worker.js
@@ -0,0 +1,11 @@
+self.addEventListener('install', (event) => {
+  event.waitUntil(
+    caches.open('v1').then((cache) => cache.addAll(['/']))
+  );
+});
+
+self.addEventListener('fetch', (event) => {
+  event.respondWith(
+    caches.match(event.request).then((response) => response || fetch(event.request))
+  );
+});
diff --git a/src/api/spotify.js b/src/api/spotify.js
new file mode 100644
index 0000000..cde8339
--- /dev/null
+++ b/src/api/spotify.js
@@ -0,0 +1,34 @@
+import axios from 'axios';
+import { useAuthStore } from '@/stores/auth';
+
+const api = axios.create({
+    baseURL: 'https://api.spotify.com/v1'
+});
+
+api.interceptors.request.use((config) => {
+    const auth = useAuthStore();
+    if (auth.accessToken) {
+        config.headers.Authorization = `Bearer ${auth.accessToken}`;
+    }
+    return config;
+});
+
+api.interceptors.response.use(
+    (response) => response,
+    async (error) => {
+        if (error.response && error.response.status === 401) {
+            const auth = useAuthStore();
+            const newToken = await auth.refreshAccessToken(
+                import.meta.env.VITE_SPOTIFY_CLIENT_ID,
+                import.meta.env.VITE_SPOTIFY_CLIENT_SECRET
+            );
+            if (newToken) {
+                error.config.headers.Authorization = `Bearer ${newToken}`;
+                return api.request(error.config);
+            }
+        }
+        return Promise.reject(error);
+    }
+);
+
+export default api;
diff --git a/src/layout/AppMenu.vue b/src/layout/AppMenu.vue
index eb846fe..bd5a177 100644
--- a/src/layout/AppMenu.vue
+++ b/src/layout/AppMenu.vue
@@ -1,35 +1,37 @@
 <script setup>
 import { ref } from 'vue';
 
 import AppMenuItem from './AppMenuItem.vue';
 
 const model = ref([
     {
         label: 'Home',
         items: [
             { label: 'Dashboard', icon: 'pi pi-fw pi-home', to: '/dashboard' },
+            { label: 'Récents', icon: 'pi pi-fw pi-clock', to: '/recent' },
+            { label: 'Bibliothèque', icon: 'pi pi-fw pi-heart', to: '/library' },
             { label: 'Statistiques', icon: 'pi pi-fw pi-chart-bar', to: '/stats' }
         ]
     },
     {
         label: 'Pages',
         icon: 'pi pi-fw pi-briefcase',
         to: '/pages',
         items: [
             {
                 label: 'Login',
                 icon: 'pi pi-fw pi-user',
                 to:'/login'
             }
         ]
     }
 ]);
 </script>
 
 <template>
     <ul class="layout-menu">
         <template v-for="(item, i) in model" :key="item">
             <app-menu-item v-if="!item.separator" :item="item" :index="i"></app-menu-item>
             <li v-if="item.separator" class="menu-separator"></li>
         </template>
     </ul>
diff --git a/src/main.js b/src/main.js
index 49d4938..4f14579 100644
--- a/src/main.js
+++ b/src/main.js
@@ -6,25 +6,31 @@ import { createApp } from 'vue';
 import App from './App.vue';
 import router from './router';
 
 import Aura from '@primeuix/themes/aura';
 import PrimeVue from 'primevue/config';
 
 import '@/assets/styles.scss';
 
 const app = createApp(App);
 const pinia = createPinia();
 app.use(pinia);
 
 app.use(router);
 app.use(PrimeVue, {
     theme: {
         preset: Aura,
         options: {
             darkModeSelector: '.app-dark'
         }
     }
 });
 app.use(ToastService);
 app.use(ConfirmationService);
 
 app.mount('#app');
+
+if ('serviceWorker' in navigator) {
+    window.addEventListener('load', () => {
+        navigator.serviceWorker.register('/service-worker.js');
+    });
+}
diff --git a/src/router/index.js b/src/router/index.js
index 5bc3b54..b479660 100644
--- a/src/router/index.js
+++ b/src/router/index.js
@@ -1,26 +1,39 @@
 import AppLayout from '@/layout/AppLayout.vue';
 import { createRouter, createWebHistory } from 'vue-router';
 
 const router = createRouter({
     history: createWebHistory(),
     routes: [
         {
             path: '/',
             component: AppLayout,
             children: [
                 { path: '/home', component: () => import('@/views/Home.vue') },
                 { path: '/playlist/:id', component: () => import('@/views/PlaylistDetail.vue'), props: true },
                 { path: '/dashboard', component: () => import('@/views/Dashboard.vue') },
                 { path: '/stats', component: () => import('@/views/Stats.vue') },
+                { path: '/recent', component: () => import('@/views/RecentlyPlayed.vue') },
+                { path: '/library', component: () => import('@/views/LikedSongs.vue') },
                 { path: '/login', component: () => import('@/views/Login.vue') },
                 {
                     path: '/spotify/callback',
                     component: () => import('@/views/RedirectLogin.vue'),
                     props: (route) => ({ code: route.query.code })
                 }
             ]
         }
     ]
 });
 
+import { useAuthStore } from '@/stores/auth';
+
+router.beforeEach((to, from, next) => {
+    const auth = useAuthStore();
+    if (to.path !== '/login' && !auth.isAuthenticated) {
+        next('/login');
+    } else {
+        next();
+    }
+});
+
 export default router;
diff --git a/src/views/Dashboard.vue b/src/views/Dashboard.vue
index 04e0021..cdc742c 100644
--- a/src/views/Dashboard.vue
+++ b/src/views/Dashboard.vue
@@ -1,113 +1,103 @@
 <script setup>
 import router from '@/router';
 import { useAuthStore } from '@/stores/auth';
 import { useUserStore } from '@/stores/user';
-import axios from 'axios';
+import api from '@/api/spotify';
 import { useToast } from 'primevue/usetoast';
 import { onMounted, ref } from 'vue';
 
 const clientId = import.meta.env.VITE_SPOTIFY_CLIENT_ID;
 const clientSecret = import.meta.env.VITE_SPOTIFY_CLIENT_SECRET;
 const userStore = useUserStore();
 const authStore = useAuthStore();
 const access_token = ref(authStore.accessToken);
 const refresh_token = ref(authStore.refreshToken);
 const code = sessionStorage.getItem('code');
 const toast = useToast();
 const playlists = ref([]);
 const isLoading = ref(true);
 const errorMessage = ref(null);
 
 // 🚀 Fetch user data on mount
 onMounted(async () => {
     if (refresh_token.value && !access_token.value) {
         console.log('🔄 Refreshing token...');
         access_token.value = await authStore.refreshAccessToken(clientId, clientSecret);
     }
 
     if (!access_token.value && code) {
         console.log('🔑 Obtaining new access token...');
         const tokens = await getAccessToken(clientId, code);
         authStore.setTokens(tokens.access_token, tokens.refresh_token);
         access_token.value = tokens.access_token;
     }
 
     if (access_token.value) {
-        const profile = await fetchProfile(access_token.value);
+        const profile = await fetchProfile();
         console.log('👤 Profile Retrieved:', profile);
         sessionStorage.setItem('user_id', profile.id);
         userStore.user = profile;
     }
     await fetchPlaylists();
 });
 // 🔄 Fonction pour obtenir un token d'accès
 async function getAccessToken(clientId, code) {
     const verifier = sessionStorage.getItem('verifier');
 
     const params = new URLSearchParams();
     params.append('client_id', clientId);
     params.append('grant_type', 'authorization_code');
     params.append('code', code);
-    params.append('redirect_uri', 'http://localhost:5173/spotify/callback/');
+    params.append('redirect_uri', import.meta.env.VITE_SPOTIFY_REDIRECT_URI);
     params.append('code_verifier', verifier);
 
     const result = await fetch('https://accounts.spotify.com/api/token', {
         method: 'POST',
         headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
         body: params
     });
 
     const { access_token, refresh_token } = await result.json();
     authStore.setTokens(access_token, refresh_token);
     return { access_token, refresh_token };
 }
 
 // 🔹 Récupérer le profil utilisateur
-async function fetchProfile(token) {
-    const result = await fetch('https://api.spotify.com/v1/me', {
-        method: 'GET',
-        headers: { Authorization: `Bearer ${token}` }
-    });
-    if (result.status === 401) {
-        console.log('🔑 Token expired, refreshing...');
-        access_token.value = await authStore.refreshAccessToken(clientId, clientSecret);
-        return await fetchProfile(access_token.value);
-    }
-    return await result.json();
+async function fetchProfile() {
+    const response = await api.get('/me');
+    return response.data;
 }
 const fetchPlaylists = async () => {
     if (!userStore.user?.id) {
         errorMessage.value = 'Utilisateur non connecté.';
         isLoading.value = false;
         return;
     }
 
     try {
-        const response = await axios.get(`https://api.spotify.com/v1/users/${userStore.user.id}/playlists`, {
-            headers: { Authorization: `Bearer ${authStore.accessToken}` }
-        });
+        const response = await api.get(`/users/${userStore.user.id}/playlists`);
 
         playlists.value = response.data.items;
         console.log('✅ Playlists récupérées :', playlists.value);
 
         if (playlists.value.length === 0) {
             errorMessage.value = 'Aucune playlist trouvée.';
         }
     } catch (error) {
         console.error('❌ Erreur lors de la récupération des playlists :', error);
         errorMessage.value = 'Impossible de récupérer les playlists.';
         toast.add({ severity: 'error', summary: 'Erreur', detail: error.message, life: 3000 });
     } finally {
         isLoading.value = false;
     }
 };
 const goToPlaylist = (playlistId) => {
     router.push(`/playlist/${playlistId}`);
 };
 </script>
 <template>
     <div class="p-4">
         <h2 class="text-xl font-bold mb-4">🎵 Vos Playlists</h2>
 
         <!-- 🔄 Affichage du chargement -->
         <ProgressSpinner v-if="isLoading" />
diff --git a/src/views/Home.vue b/src/views/Home.vue
index 1ea085d..ea74cf1 100644
--- a/src/views/Home.vue
+++ b/src/views/Home.vue
@@ -1,105 +1,101 @@
 <script setup>
 import { useUserStore } from '@/stores/user';
 import { useAuthStore } from '@/stores/auth';
-import axios from 'axios';
+import api from '@/api/spotify';
 import { useToast } from 'primevue/usetoast';
 import { ref, watch, computed } from 'vue';
 
 
 const userStore = useUserStore();
 const authStore = useAuthStore();
 const access_token = computed(() => authStore.accessToken);
 const filteredTracks = ref('')
 const playlist = ref(null);
 const tracks = ref([]); // ✅ Store all tracks separately
 const isLoading = ref(false);
 const errorMessage = ref(null);
 const artist = ref('');
 const toast = useToast();
 const search = ref('');
 const displayDialog = ref(false);
 
 // 🔄 Function to fetch playlist & tracks (with pagination)
 const fetchPlaylist = async (playlistId) => {
     isLoading.value = true;
     tracks.value = []; // Reset tracks
 
     try {
         // Fetch playlist details
-        const playlistResponse = await axios.get(`https://api.spotify.com/v1/playlists/${playlistId}`, {
-            headers: { Authorization: `Bearer ${access_token.value}` }
-        });
+        const playlistResponse = await api.get(`/playlists/${playlistId}`);
 
         playlist.value = playlistResponse.data;
         console.log("🎵 Playlist Retrieved:", playlist.value);
         const totalTracks = playlist.value.tracks.total;
         const limit = 100;
         let offset = 0;
 
         // Fetch tracks with pagination
         while (offset < totalTracks) {
-            const trackResponse = await axios.get(
-                `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=${limit}&offset=${offset}`,
-                { headers: { Authorization: `Bearer ${access_token.value}` } }
-            );
+            const trackResponse = await api.get(`/playlists/${playlistId}/tracks`, {
+                params: { limit, offset }
+            });
             tracks.value = tracks.value.concat(trackResponse.data.items);
             offset += limit;
         }
         filteredTracks.value = tracks.value;
         isLoading.value = false;
     } catch (error) {
         errorMessage.value = error.message;
         toast.add({ severity: 'error', summary: 'Erreur', detail: error.message, life: 3000 });
         isLoading.value = false;
     }
 };
 
 // 🔍 Extract Playlist ID from Spotify URL
 const standardizeUrl = (url) => {
     const regex = /https:\/\/open\.spotify\.com\/(playlist|track|album|artist)\/([a-zA-Z0-9]+)/;
     const match = url.match(regex);
     return match ? match[2] : null;
 };
 
 // 🔍 Search Handler
 const fetchEntity = async () => {
     const playlistId = standardizeUrl(search.value);
     if (!playlistId) {
         toast.add({ severity: 'error', summary: 'Erreur', detail: 'URL Spotify invalide', life: 3000 });
         return;
     }
     await fetchPlaylist(playlistId);
 };
 
 
 const deleteTracks = async () => {
     const tracksUri = filteredTracks.value.map(t=> ({uri:t.track.uri}));
     console.log(tracksUri)
-    await axios.delete(`https://api.spotify.com/v1/playlists/${playlist.value.id}/tracks`, {
-        headers: { Authorization: `Bearer ${access_token.value}` },
-        data: { tracks:tracksUri }
+    await api.delete(`/playlists/${playlist.value.id}/tracks`, {
+        data: { tracks: tracksUri }
     });
     displayDialog.value = false;
 }
 watch(artist, async () => {
     if(artist.value.length > 2) {
         filteredTracks.value = tracks.value.filter(t=> t.track.artists[0].name
         .toLocaleLowerCase().includes(artist.value.toLocaleLowerCase()));
     }
     else {
         filteredTracks.value = tracks.value;
     }
 
 });
 </script>
 
 <template>
     <div class="p-4">
         <Message severity="success">Bienvenue sur Spotify</Message>
         <p v-if="userStore.user">👤 Connecté en tant que {{ userStore.user?.display_name }}</p>
         <p v-else>🔄 Connexion en cours...</p>
 
         <!-- Input & Button -->
         <div class="mb-4">
             <InputText default-value="https://open.spotify.com/playlist/3mLNDkROovyTlvZy4ucpwh?si=62a83601edf747be" class="w-full mb-2" v-model="search" @keydown.enter.prevent="fetchEntity" placeholder="Collez le lien Spotify ici" />
             <InputText  class="w-full mb-2" v-model="artist" placeholder="Entrez le nom d'un artiste " />
diff --git a/src/views/LikedSongs.vue b/src/views/LikedSongs.vue
new file mode 100644
index 0000000..4f3fce6
--- /dev/null
+++ b/src/views/LikedSongs.vue
@@ -0,0 +1,52 @@
+<script setup>
+import { ref, onMounted } from 'vue';
+import api from '@/api/spotify';
+
+const tracks = ref([]);
+const isLoading = ref(false);
+const errorMessage = ref(null);
+
+const fetchLiked = async () => {
+    isLoading.value = true;
+    try {
+        const { data } = await api.get('/me/tracks', { params: { limit: 20 } });
+        tracks.value = data.items;
+    } catch (e) {
+        console.error(e);
+        errorMessage.value = "Impossible de récupérer les musiques likées";
+    } finally {
+        isLoading.value = false;
+    }
+};
+
+const removeTrack = async (id) => {
+    try {
+        await api.delete('/me/tracks', { params: { ids: id } });
+        tracks.value = tracks.value.filter(t => t.track.id !== id);
+    } catch (e) {
+        console.error(e);
+    }
+};
+
+onMounted(fetchLiked);
+</script>
+
+<template>
+    <div class="p-4">
+        <h2 class="text-xl font-bold mb-4">💚 Musiques likées</h2>
+        <ProgressSpinner v-if="isLoading" />
+        <div v-if="errorMessage" class="text-red-500">{{ errorMessage }}</div>
+        <ul v-if="tracks.length" class="space-y-2">
+            <li v-for="item in tracks" :key="item.track.id" class="flex items-center">
+                <img :src="item.track.album.images[0]?.url" class="w-10 h-10 rounded mr-2" />
+                <div class="flex-1">
+                    <p class="font-medium">{{ item.track.name }}</p>
+                    <p class="text-xs text-gray-500">{{ item.track.artists.map(a => a.name).join(', ') }}</p>
+                </div>
+                <Button icon="pi pi-trash" severity="danger" @click="removeTrack(item.track.id)" />
+            </li>
+        </ul>
+    </div>
+</template>
+
+<style scoped></style>
diff --git a/src/views/Login.vue b/src/views/Login.vue
index bfd0ef6..07cef1f 100644
--- a/src/views/Login.vue
+++ b/src/views/Login.vue
@@ -8,48 +8,48 @@ function generateCodeVerifier(length) {
     let text = '';
     let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
     for (let i = 0; i < length; i++) {
         text += possible.charAt(Math.floor(Math.random() * possible.length));
     }
     return text;
 }
 
 async function generateCodeChallenge(codeVerifier) {
     const data = new TextEncoder().encode(codeVerifier);
     const digest = await window.crypto.subtle.digest('SHA-256', data);
     return btoa(String.fromCharCode.apply(null, [...new Uint8Array(digest)]))
         .replace(/\+/g, '-')
         .replace(/\//g, '_')
         .replace(/=+$/, '');
 }
 
 async function redirectToAuthCodeFlow(clientId) {
     const verifier = generateCodeVerifier(128);
     const challenge = await generateCodeChallenge(verifier);
     sessionStorage.setItem('verifier', verifier);
 
     const params = new URLSearchParams();
     params.append('client_id', clientId);
     params.append('response_type', 'code');
-    params.append('redirect_uri', 'http://localhost:5173/spotify/callback/');
+    params.append('redirect_uri', import.meta.env.VITE_SPOTIFY_REDIRECT_URI);
     params.append('scope', 'user-read-private user-read-email playlist-modify-public playlist-modify-private user-top-read user-read-recently-played user-library-read user-library-modify');
     params.append('code_challenge_method', 'S256');
     params.append('code_challenge', challenge);
 
     document.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
 }
 
 const login = async () => {
     if (!code) {
         console.log(code);
         redirectToAuthCodeFlow(clientId);
     } else {
         router.push('/home');
     }
 };
 </script>
 
 <template>
     <div>
         <Button v-on:click="login" label="Se connecter avec Spotify" icon="fab fa-spotify" />
     </div>
 </template>
diff --git a/src/views/PlaylistDetail.vue b/src/views/PlaylistDetail.vue
index 4768d99..333131b 100644
--- a/src/views/PlaylistDetail.vue
+++ b/src/views/PlaylistDetail.vue
@@ -1,224 +1,215 @@
 <script setup>
-import axios from 'axios';
+import api from '@/api/spotify';
 import { onMounted, ref, watch, computed } from 'vue';
 import { useAuthStore } from '@/stores/auth';
 import { useRoute } from 'vue-router';
 import { useToast } from 'primevue/usetoast';
 const route = useRoute();
 const authStore = useAuthStore();
 const accessToken = computed(() => authStore.accessToken);
 const playlist = ref(null);
 const tracks = ref([]);
 const isLoading = ref(true);
 const errorMessage = ref(null);
 const offset = ref(0);
 const totalTracks = ref(0);
 const currentPage = ref(1);
 const genres = ref({});
 const showDialog = ref(false);
 const selectedGenres = ref([]); // ✅ Ne pas pré-sélectionner
 const selectedTracks = ref([]);
 const isPublic = ref(false);
 const name = ref('');
 const description = ref('');
 let selected = new Map();
 const toast = useToast();
 
 // 📌 Log des musiques sélectionnées sans doublons
 const logSelectedTracks = async () => {
     try {
-        const response = await axios.post(
-            `https://api.spotify.com/v1/users/${sessionStorage.getItem('user_id')}/playlists`,
+        const response = await api.post(
+            `/users/${sessionStorage.getItem('user_id')}/playlists`,
             {
                 name: name.value,
                 description: description.value,
                 public: isPublic.value
-            }, // ✅ Ce bloc est le body de la requête
-            {
-                headers: { Authorization: `Bearer ${accessToken.value}` }
-            } // ✅ Les headers sont dans le 3ème argument
+            }
         );
         const playlistId = response.data.id;
         if (selected.size > 50) {
             sendTracksToPlaylist(playlistId, selected);
         } else {
-            await axios.post(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, { uris: Array.from(selected.keys()) }, { headers: { Authorization: `Bearer ${accessToken.value}` } });
+            await api.post(`/playlists/${playlistId}/tracks`, { uris: Array.from(selected.keys()) });
         }
     } catch (error) {
         console.error('❌ Erreur ajout des morceaux :', error.response?.data || error);
     }
 };
 
 const sendTracksToPlaylist = async (playlistId, selected) => {
     const trackUris = Array.from(selected.keys()); // Convertit la Map en tableau d'URIs
     const currentToken = accessToken.value;
 
     try {
         for (let i = 0; i < trackUris.length; i += 50) {
             const batch = trackUris.slice(i, i + 50); // Découpe en lots de 50
-            await axios.post(
-                `https://api.spotify.com/v1/playlists/${playlistId}/tracks`,
-                { uris: batch }, // Envoie le lot de 50 morceaux
-                { headers: { Authorization: `Bearer ${currentToken}` } }
+            await api.post(
+                `/playlists/${playlistId}/tracks`,
+                { uris: batch }
             );
 
             console.log(`✅ Envoyé ${i + 1}-${Math.min(i + 50, trackUris.length)} sur ${trackUris.length}`);
         }
 
         console.log('🎉 Tous les morceaux ont été ajoutés !');
     } catch (error) {
         console.error("❌ Erreur lors de l'ajout des morceaux :", error.response?.data || error);
     }
 };
 
 // 📌 Récupération des détails de la playlist
 const fetchPlaylistDetails = async () => {
     isLoading.value = true;
     let artistsMap = new Map();
     let genresMap = new Map();
     let nextUrl = `https://api.spotify.com/v1/playlists/${route.params.id}`;
 
     try {
         let firstRequest = true;
         let allTracks = [];
 
         while (nextUrl) {
-            const response = await axios.get(nextUrl, {
-                headers: { Authorization: `Bearer ${accessToken.value}` }
-            });
+            const response = await api.get(nextUrl);
             if (firstRequest) {
                 playlist.value = response.data;
                 totalTracks.value = response.data.tracks.total;
             }
 
             let tracks = firstRequest ? response.data.tracks.items : response.data.items;
             firstRequest = false;
 
             tracks.forEach((track) => {
                 allTracks.push(track.track);
                 track.track.artists.forEach((artist) => {
                     artistsMap.set(artist.id, null);
                 });
             });
             if (response.data.tracks?.next == undefined) {
                 nextUrl = response.data.next;
             } else {
                 nextUrl = response.data.tracks.next;
             }
             console.log(nextUrl);
         }
 
         console.log(`✅ Total morceaux trouvés : ${allTracks.length}`);
 
         // 📌 Récupération des artistes
         const artistsArray = [...artistsMap.keys()];
         let allArtists = [];
 
         for (let i = 0; i < artistsArray.length; i += 50) {
             const batch = artistsArray.slice(i, i + 50).join(',');
-            const responseArtists = await axios.get(`https://api.spotify.com/v1/artists`, {
-                headers: { Authorization: `Bearer ${accessToken.value}` },
+            const responseArtists = await api.get('/artists', {
                 params: { ids: batch }
             });
 
             responseArtists.data.artists.forEach((artist) => {
                 artistsMap.set(artist.id, artist);
                 allArtists.push(artist);
             });
         }
 
         console.log(`✅ Total artistes détaillés récupérés : ${allArtists.length}`);
 
         // 📌 Association des morceaux aux genres sans doublons
         allTracks.forEach((track) => {
             track.artists.forEach((artist) => {
                 let artistData = artistsMap.get(artist.id);
                 if (artistData && artistData.genres) {
                     artistData.genres.forEach((genre) => {
                         if (!genresMap.has(genre)) {
                             genresMap.set(genre, new Map()); // Utiliser un Map pour éviter les doublons
                         }
                         genresMap.get(genre).set(track.id, { id: track.id, name: track.name });
                     });
                 }
             });
         });
 
         // 📌 Transformation en objet clé-valeur propre
         genres.value = Object.fromEntries([...genresMap.entries()].map(([genre, tracksMap]) => [genre, Array.from(tracksMap.values())]));
 
         console.log(`✅ Genres associés aux morceaux :`, genres.value);
 
         fetchTracks(0);
     } catch (error) {
         console.error('❌ Erreur récupération playlist :', error);
         errorMessage.value = 'Impossible de récupérer la playlist.';
     } finally {
         isLoading.value = false;
     }
 };
 
 // 📌 Récupération des morceaux avec pagination
 const fetchTracks = async (newOffset) => {
     isLoading.value = true;
     try {
-        const response = await axios.get(`https://api.spotify.com/v1/playlists/${route.params.id}/tracks`, {
-            headers: { Authorization: `Bearer ${accessToken.value}` },
+        const response = await api.get(`/playlists/${route.params.id}/tracks`, {
             params: { limit: 20, offset: newOffset }
         });
 
         tracks.value = response.data.items;
         offset.value = newOffset;
         currentPage.value = Math.floor(newOffset / 20) + 1;
         totalTracks.value = response.data.total;
     } catch (error) {
         console.error('❌ Erreur récupération des morceaux :', error);
     } finally {
         isLoading.value = false;
     }
 };
 const addSelectedTracks = async () => {
     selectedGenres.value.forEach((genre) => {
         selectedTracks.value.push(genres.value[genre]);
     });
     Object.keys(selectedTracks.value).forEach((genre) => {
         if (selectedTracks.value[genre]) {
             selectedTracks.value[genre].forEach((track) => {
                 if (!selected.has(track.id)) {
                     selected.set(`spotify:track:${track.id}`);
                 }
             });
         }
     });
     console.log(selected);
 };
 
 const deleteTrack = async (trackUri, trackId) => {
     try {
-        await axios.delete(`https://api.spotify.com/v1/playlists/${playlist.value.id}/tracks`, {
-            headers: { Authorization: `Bearer ${accessToken.value}` },
+        await api.delete(`/playlists/${playlist.value.id}/tracks`, {
             data: { tracks: [{ uri: trackUri }] }
         });
         tracks.value = tracks.value.filter((t) => t.track.id !== trackId);
         toast.add({ severity: 'success', summary: 'Supprimé', detail: 'Morceau supprimé', life: 3000 });
     } catch (error) {
         console.error('❌ Erreur suppression morceau :', error);
         toast.add({ severity: 'error', summary: 'Erreur', detail: 'Suppression impossible', life: 3000 });
     }
 };
 onMounted(fetchPlaylistDetails);
 watch(() => route.params.id, fetchPlaylistDetails);
 </script>
 
 <template>
     <div class="p-4">
         <Button label="⬅ Retour" class="p-button-outlined mb-4" @click="$router.push('/dashboard')" />
 
         <Card class="playlist-info mb-6" v-if="playlist">
             <template #header>
                 <img v-if="playlist.images.length" :src="playlist.images[0].url" class="playlist-cover" />
             </template>
             <template #title>{{ playlist.name }}</template>
             <template #subtitle>Par {{ playlist.owner?.display_name }}</template>
             <template #content>
                 <p class="text-sm text-gray-600">{{ playlist.description }}</p>
@@ -253,50 +244,51 @@ watch(() => route.params.id, fetchPlaylistDetails);
                             <label :for="genre" class="ml-2">{{ genre }}</label>
                         </div>
 
                         <!-- Dropdown avec les morceaux du genre (pré-sélectionnés) -->
                         <Dropdown v-if="selectedGenres.includes(genre)" v-model="selectedTracks[genre]" :options="tracks" optionLabel="name" placeholder="Musiques du genre" class="w-full mt-2" multiple />
                     </div>
                 </div>
 
                 <!-- Bouton pour afficher les morceaux sélectionnés en console -->
                 <template #footer>
                     <Button label="Afficher la sélection" icon="pi pi-check" @click="logSelectedTracks" />
                 </template>
             </Dialog>
         </div>
 
         <!-- 🎵 Grid des morceaux -->
         <div v-if="tracks.length > 0" class="tracks-grid">
             <Card v-for="track in tracks" :key="track.track.id" class="track-card">
                 <template #header>
                     <img :src="track.track.album.images[0]?.url" alt="Cover" class="track-cover" />
                 </template>
                 <template #title>{{ track.track.name }}</template>
                 <template #subtitle>{{ track.track.artists.map((a) => a.name).join(', ') }}</template>
                 <template #content>
                     <p class="text-gray-600 text-sm">{{ track.track.album.name }}</p>
+                    <audio v-if="track.track.preview_url" :src="track.track.preview_url" controls class="w-full mt-2" />
                 </template>
                 <template #footer>
                     <div class="flex gap-2">
                         <a :href="track.track.external_urls.spotify" target="_blank" rel="noopener noreferrer" class="w-full">
                             <Button label="Écouter" icon="pi pi-play" class="p-button-sm p-button-success w-full" />
                         </a>
                         <Button label="Supprimer" icon="pi pi-trash" severity="danger" class="p-button-sm w-full" @click="deleteTrack(track.track.uri, track.track.id)" />
                     </div>
                 </template>
             </Card>
         </div>
 
         <!-- 🔄 Pagination -->
         <div class="pagination">
             <Button label="⬅ Précédent" :disabled="offset === 0" @click="fetchTracks(offset - 20)" />
             <span class="pagination-info">Page {{ currentPage }}</span>
             <Button label="Suivant ➡" :disabled="offset + 20 >= totalTracks" @click="fetchTracks(offset + 20)" />
         </div>
     </div>
 </template>
 
 <style scoped>
 .playlist-cover {
     width: 100%;
     max-width: 400px;
diff --git a/src/views/RecentlyPlayed.vue b/src/views/RecentlyPlayed.vue
new file mode 100644
index 0000000..efd492d
--- /dev/null
+++ b/src/views/RecentlyPlayed.vue
@@ -0,0 +1,42 @@
+<script setup>
+import { onMounted, ref } from 'vue';
+import api from '@/api/spotify';
+
+const recent = ref([]);
+const isLoading = ref(false);
+const errorMessage = ref(null);
+
+const fetchRecent = async () => {
+    isLoading.value = true;
+    try {
+        const { data } = await api.get('/me/player/recently-played', { params: { limit: 20 } });
+        recent.value = data.items;
+    } catch (err) {
+        errorMessage.value = 'Impossible de récupérer l\'historique';
+        console.error(err);
+    } finally {
+        isLoading.value = false;
+    }
+};
+
+onMounted(fetchRecent);
+</script>
+
+<template>
+    <div class="p-4">
+        <h2 class="text-xl font-bold mb-4">🎧 Récemment écoutés</h2>
+        <ProgressSpinner v-if="isLoading" />
+        <div v-if="errorMessage" class="text-red-500">{{ errorMessage }}</div>
+        <ul v-if="recent.length" class="space-y-2">
+            <li v-for="item in recent" :key="item.played_at" class="flex items-center">
+                <img :src="item.track.album.images[0]?.url" class="w-10 h-10 rounded mr-2" />
+                <div>
+                    <p class="font-medium">{{ item.track.name }}</p>
+                    <p class="text-xs text-gray-500">{{ item.track.artists.map(a => a.name).join(', ') }}</p>
+                </div>
+            </li>
+        </ul>
+    </div>
+</template>
+
+<style scoped></style>
diff --git a/src/views/Stats.vue b/src/views/Stats.vue
index 600335e..b1758b1 100644
--- a/src/views/Stats.vue
+++ b/src/views/Stats.vue
@@ -1,83 +1,97 @@
 <script setup>
-import axios from 'axios';
+import api from '@/api/spotify';
 import { ref, computed, onMounted } from 'vue';
 import { useAuthStore } from '@/stores/auth';
 
 const authStore = useAuthStore();
 const accessToken = computed(() => authStore.accessToken);
 
 const timeRange = ref('short_term');
 const timeOptions = [
   { label: '1 mois', value: 'short_term' },
   { label: '6 mois', value: 'medium_term' },
   { label: '1 an', value: 'long_term' }
 ];
 
 const topTracks = ref([]);
 const topArtists = ref([]);
+const audioFeatures = ref({});
 const isLoading = ref(false);
 const errorMessage = ref(null);
 
 const listeningTime = computed(() => {
   const total = topTracks.value.reduce((sum, t) => sum + t.duration_ms, 0);
   return Math.round(total / 60000);
 });
 
 const fetchStats = async () => {
   isLoading.value = true;
   errorMessage.value = null;
   try {
-    const headers = { Authorization: `Bearer ${accessToken.value}` };
-    const tracksRes = await axios.get('https://api.spotify.com/v1/me/top/tracks', {
-      headers,
+    const tracksRes = await api.get('/me/top/tracks', {
       params: { limit: 10, time_range: timeRange.value }
     });
-    const artistsRes = await axios.get('https://api.spotify.com/v1/me/top/artists', {
-      headers,
+    const artistsRes = await api.get('/me/top/artists', {
       params: { limit: 10, time_range: timeRange.value }
     });
     topTracks.value = tracksRes.data.items;
     topArtists.value = artistsRes.data.items;
+
+    const ids = topTracks.value.map(t => t.id).join(',');
+    if (ids) {
+      const featuresRes = await api.get('/audio-features', { params: { ids } });
+      audioFeatures.value = featuresRes.data.audio_features.reduce((acc, f) => {
+        acc[f.id] = f;
+        return acc;
+      }, {});
+    } else {
+      audioFeatures.value = {};
+    }
   } catch (err) {
     console.error('Erreur stats', err);
     errorMessage.value = "Impossible de récupérer les statistiques.";
   } finally {
     isLoading.value = false;
   }
 };
 
 onMounted(fetchStats);
 </script>
 
 <template>
   <div class="p-4">
     <h2 class="text-xl font-bold mb-4">📊 Vos Statistiques</h2>
     <div class="mb-4">
       <Dropdown v-model="timeRange" :options="timeOptions" optionLabel="label" optionValue="value" @change="fetchStats" class="w-full md:w-40" />
     </div>
     <ProgressSpinner v-if="isLoading" />
     <div v-if="errorMessage" class="text-red-500">{{ errorMessage }}</div>
     <div v-if="!isLoading && !errorMessage">
       <h3 class="text-lg font-semibold mb-2">🎵 Top 10 chansons</h3>
       <ul class="mb-6">
         <li v-for="track in topTracks" :key="track.id" class="mb-2 flex items-center">
           <img :src="track.album.images[0]?.url" alt="cover" class="w-10 h-10 rounded mr-2" />
           <span class="font-medium">{{ track.name }}</span>
           <span class="text-sm text-gray-500 ml-1">- {{ track.artists.map(a => a.name).join(', ') }}</span>
+          <div v-if="audioFeatures[track.id]" class="ml-2 text-xs text-gray-600">
+            Énergie: {{ audioFeatures[track.id].energy }},
+            Dansabilité: {{ audioFeatures[track.id].danceability }},
+            Valence: {{ audioFeatures[track.id].valence }}
+          </div>
         </li>
       </ul>
       <h3 class="text-lg font-semibold mb-2">🎤 Top 10 artistes</h3>
       <ul class="mb-6">
         <li v-for="artist in topArtists" :key="artist.id" class="mb-2 flex items-center">
           <img :src="artist.images[0]?.url" alt="artist" class="w-10 h-10 rounded-full mr-2" />
           <span class="font-medium">{{ artist.name }}</span>
         </li>
       </ul>
       <h3 class="text-lg font-semibold mb-2">⏱ Temps d'écoute approximatif</h3>
       <p>{{ listeningTime }} minutes</p>
     </div>
   </div>
 </template>
 
 <style scoped>
 </style>
